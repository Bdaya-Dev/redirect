/// Embedded JavaScript source for redirect web assets.
///
/// These constants contain the full source of the JS files that need to be
/// placed in the consumer's `web/` directory for redirect callback handling.
///
/// ## Quick setup
///
/// Run the setup CLI to copy the files automatically:
///
/// ```sh
/// dart run redirect_web_core:setup
/// ```
///
/// ## Why manual setup is required
///
/// Flutter/Dart has no mechanism to auto-copy files to the web root from a
/// package. Service Workers **must** be registered from a same-origin URL
/// (Blob and data URLs are rejected by browsers), and the callback page must
/// exist at the redirect URI path. This means the `.js` and `.html` files
/// must physically exist in the consumer's `web/` directory.
///
/// ## What each file does
///
/// | File | Purpose | Required? |
/// |------|---------|-----------|
/// | `redirect_sw.js` | Service Worker -- intercepts callback navigations and broadcasts via BroadcastChannel | Required (recommended path) |
/// | `redirect_callback.js` | Fallback -- relays the URL via BroadcastChannel | Only if SW is not used |
library;

/// Provides access to the JavaScript source files that ship with the
/// `redirect_web_core` package.
///
/// These files must be placed in the consumer app's `web/` directory.
/// Use `dart run redirect_web_core:setup` to copy them automatically,
/// or reference these constants in a custom build script.
abstract final class RedirectWebAssets {
  /// Service Worker JavaScript source.
  ///
  /// Must be placed at the web root (e.g. `web/redirect_sw.js`) because
  /// browsers reject Service Worker registration from Blob or data URLs.
  ///
  /// Registered automatically when [WebRedirectOptions.autoRegisterServiceWorker]
  /// is `true`.
  static const serviceWorkerJs = '''
// redirect_sw.js -- Service Worker for redirect callback handling.
//
// Intercepts navigation requests to the configured callback path and
// broadcasts the full URL to all active redirect channels via
// BroadcastChannel -- directly from the SW context.
//
// Generated by: dart run redirect_web_core:setup

var callbackPath = '/callback';
var channels = new Set();

self.addEventListener('message', function (event) {
  var data = event.data;
  if (!data || !data.type) return;
  switch (data.type) {
    case 'redirect_config':
      if (data.callbackPath) callbackPath = data.callbackPath;
      break;
    case 'redirect_register':
      if (data.channel) channels.add(data.channel);
      break;
    case 'redirect_unregister':
      if (data.channel) channels.delete(data.channel);
      break;
  }
});

self.addEventListener('install', function () {
  self.skipWaiting();
});

self.addEventListener('activate', function (event) {
  event.waitUntil(self.clients.claim());
});

self.addEventListener('fetch', function (event) {
  var url = new URL(event.request.url);
  if (
    event.request.mode !== 'navigate' ||
    url.origin !== self.location.origin ||
    url.pathname !== callbackPath
  ) {
    return;
  }
  channels.forEach(function (name) {
    try {
      var ch = new BroadcastChannel(name);
      ch.postMessage(url.href);
      ch.close();
    } catch (_) {}
  });
  // Do NOT call event.respondWith -- let the normal navigation proceed.
});
''';

  /// Callback-page JavaScript source (fallback).
  ///
  /// Only needed if you are **not** using the Service Worker. When using
  /// the SW (recommended), the callback page does not need any JavaScript.
  ///
  /// Reads registered channels from `localStorage`, broadcasts
  /// `window.location.href` to each via `BroadcastChannel`, and
  /// auto-closes after 1.5 s.
  ///
  /// Include on your callback page:
  /// ```html
  /// <script src="redirect_callback.js"></script>
  /// ```
  static const callbackJs = '''
(function () {
  'use strict';
  var STORAGE_PREFIX = 'redirect_channels_';
  var callbackUrl = window.location.href;
  var scheme = window.location.protocol.replace(':', '');

  // Support _scheme query parameter for custom-scheme mapping.
  var params = new URLSearchParams(window.location.search);
  var schemeOverride = params.get('_scheme');
  if (schemeOverride) scheme = schemeOverride;

  var storageKey = STORAGE_PREFIX + scheme;
  var channels = [];
  try {
    var raw = localStorage.getItem(storageKey);
    if (raw) channels = JSON.parse(raw);
  } catch (_) {}

  for (var i = 0; i < channels.length; i++) {
    try {
      var ch = new BroadcastChannel(channels[i]);
      ch.postMessage(callbackUrl);
      ch.close();
    } catch (_) {}
  }

  setTimeout(function () { window.close(); }, 1500);
})();
''';
}
